## PyEncoder

This script encodes shellcode with SUB EAX instructions. Provide shellcode in 4 byte chunks (DWORD) and a set of good characters and the script will produce the encoded version.

It is worth noting this is (sort of) a BRUTE FORCE method. It works like other encoding methods, but the script plays it fast and loose with some of the logic for the SUB instructions. 0x55 is subtracted from bad chars and 0x01 is subtracted from good chars. It works, but you may end up with more instructions than if you had done this by hand. If you are tight on space, then this could be an issue and you'll need to manually encode an instruction or two.

But it works.

### The Output

The script will output an encoded.asm file with all of the encoded instructions. This is suitable for use with `nasm` to create a binary file.

`nasm encoded.asm -o encoded.bin`

Rather than assume the script is being run on a machine with `nasm` available, this is done separately.

### Formatting Binary Instructions

Once you have run `nasm` and have your binary file, you can use the script to format your binary instructions into instructions suitable for copy/pasting directly into an exploit script ("\x" format).

As a bonus for this being a separate function, any binary file can be supplied. This is much like the pveReader.pl script featured in Corelan's Win32 shellcode tutorials, but it's Python.

`python encoder.py --format encoded.bin`

### Sample Output

This line of egghunter shellcode:

>\x75\xe7\xff\xe7

Becomes these decoding instructions:

>AND EAX,0x554E4D4A

>AND EAX,0x2A313235

>SUB EAX,0x55555555

>SUB EAX,0x55555501

>SUB EAX,0x6d556e35

>PUSH EAX

Once those results are sent through `nasm` and then formatted:

>\x25\x4a\x4d\x4e\x55

>\x25\x35\x32\x31\x2a

>\x2d\x55\x55\x55\x55

>\x2d\x01\x55\x55\x55

>\x2d\x35\x6e\x55\x6d

>\x50
